compound2regex <- function(x, prefix='/') {
  if(isFALSE(prefix))
    prefix=''
  x=gsub(",", "|", x)
  x=paste0(prefix, '(', x, ')')
  x
}

triple_connection_table <- function(hbtype, fwtype=hbtype, partners=c("inputs", "outputs"),
                                    threshold=1L, version=NULL, hbdetails=T,
                                    fwtypefield=c("hemibrain_type", "cell_type"),
                                    group='type') {
  partners=match.arg(partners, several.ok = T)
  if(length(fwtype)==1 && length(hbtype)==1 && isTRUE(fwtype==hbtype) && any(grepl(',', hbtype)))
    hbtype=compound2regex(hbtype)
  fwtypefield=match.arg(fwtypefield)
  if(length(partners)>1) {
    l=sapply(partners, simplify = F, function(p)
      triple_connection_table(hbtype, fwtype, partners=p, threshold = threshold, version=version, hbdetails = hbdetails, fwtypefield = fwtypefield, group=group))
    return(l)
  }
  stopifnot(isTRUE(hbdetails))
  hb=cf_partners(list(hemibrain=hbtype), partners = partners,
                 threshold=threshold, bind.rows = F)[[1]]
  fw=cf_partners(list(flywire=fwtype), partners = partners,
                 threshold = threshold, bind.rows = F)[[1]]
  stopifnot(isTRUE(version==fafbseg::flywire_connectome_data_version()))

  if(fwtypefield=='hemibrain_type')
    fw$type=fw$hemibrain_type
  compoundtypes <- unique(grep(",", fw$type, value = T))
  if(length(compoundtypes)>0) {
    # replace simple type in hb data with compound type
    for(ct in compoundtypes) {
      hb[grepl(compound2regex(ct, prefix=FALSE), hb$type),'type']=ct
    }
  }

  commoncols=intersect(colnames(hb), colnames(fw))
  x=do.call(rbind, list(hb[commoncols],fw[commoncols]))
  x$partners=partners

  if(is.character(group)) {
    x <- match_types(x, group, partners=partners)
  }
  x
}

triple_meta <- function(ids, version=fafbseg::flywire_connectome_data_version()) {
  cf_meta(ids)
}

#' Cosine cluster across hemibrain and flywire
#'
#' @details Note that for bilateral neurons it may work better to use either
#'   input partners or output partners but not both.
#'
#' @param x Hemibrain ids or a dataframe generated by
#'   \code{triple_connection_table}
#' @param fwtype Optional flywire ids interpreted by \code{flywire_ids} function
#' @param version Connectome data dump version. See
#'   \code{\link{flywire_connectome_data_version}} for details.
#' @param ... Additional arguments to heatmap
#' @param threshold Minimum connection weight to be included when finding
#'   partners
#' @param partners Whether to use output or input partners for clustering.
#'   Default now uses both.
#' @param labRow A character vector defining labels for the rows of the
#'   resultant heatmap
#' @param heatmap A logical indicating whether or not to plot the heatmap
#'   \emph{OR} a function to plot the heatmap whose argument names are
#'   compatible with \code{stats::\link{heatmap}}. \code{gplots::heatmap.2} is a
#'   good example.
#' @param nas What to do with rows/columns with NAs when computing cosine
#'   matrix. Dropping may be more mathematically satisfactory but eliminates
#'   neurons from the comparison, so the default is to set NA elements to do 0
#'   similarity.
#' @param group What column to use for grouping partners.
#' @param method the clustering method. See \code{\link{hclust}} for details.
#' @param interactive When \code{TRUE} returns a shiny-based interactive heatmap
#'
#' @return A list as returned by \code{\link{heatmap}}
#' @export
#'
#' @examples
#' \donttest{
#' # AOTU063 should be separated into two subtypes.
#' # Very clear based on output clustering and also some small morphological differences.
#' triple_cosine_plot('AOTU063', partners = 'o')
#'
#' # LAL074/LAL084 are the same type.
#' # Were incorrectly split due to annotation into separate hemibrain CBFs
#' # note that the compound type 'LAL074,LAL084' will be used to find flywire
#' # neurons but expanded to the regex "(LAL074|LAL084)" in order to find
#' # both hemibrain types
#' triple_cosine_plot('LAL074,LAL084', partners = 'i')
#' }
#' @importFrom fafbseg flywire_connectome_data_version flytable_meta flywire_partner_summary2
triple_cosine_plot <- function(x, fwtype=x, version=NULL, ..., threshold=5,
                               partners = c("outputs", "inputs"),
                               labRow='{type}_{abbreviate_datasets(dataset)}{side}',
                               group='type',
                               heatmap=TRUE,
                               interactive=FALSE,
                               nas=c('zero','drop'),
                               method=c("ward.D", "single", "complete", "average",
                                        "mcquitty", "median", "centroid", "ward.D2")) {
  method=match.arg(method)
  partners=match.arg(partners, several.ok = T)
  if(is.null(version))
    version=flywire_connectome_data_version()
  if(!is.data.frame(x))
    x=triple_connection_table(x, fwtype, partners = partners, threshold = threshold, version = version, group=group)

  cm <- multi_cosine_matrix(x, partners = partners, group=group, nas=nas)

  if(is.character(labRow) && length(labRow)==1 && any(grepl("\\{", labRow))) {
    tm=cf_meta(colnames(cm))
    labRow <- glue::glue_data(labRow, .x = tm)
  }
  if(interactive) {
    try(cv <- requireNamespace('coconat', versionCheck=list(op='>', version='0.1.0')))
    if(inherits(cv, 'try-error'))
      stop("Please install/update suggested package coconat.\n",
           "natmanager::install(pkgs = 'coconat')\n","is a good way to do this")
  }
  coconat:::cosine_heatmap(cm, interactive = interactive, labRow = labRow,
                           method = method, heatmap=heatmap, ...)
}
