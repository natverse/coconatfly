# private function taking a list of input and output connection tables
# and turning them into a cosine matrix
multi_cosine_matrix <- function(x, partners, nas, group='type') {
  if(is.data.frame(x)) {
    x=split(x, x$partners)
    partners=names(x)
  }
  # a bit of a shuffle because c(NULL, <integer64>) removes the class
  ids=unique(c(x$outputs$pre_key, x$inputs$post_key))

  if(isTRUE(group))
    group='type'

  cm=list()
  if('outputs' %in% partners) {
    groupcol <- if(isFALSE(group)) "post_key" else group
    oam <- coconat::partner_summary2adjacency_matrix(
      x[['outputs']],
      inputcol = 'pre_key',
      outputcol = groupcol,
      inputids = ids)
    cm[['cout']] = coconat::cosine_sim(oam, transpose = T)
    cm[['wout']]=sum(x[['outputs']]$weight)
  }
  if('inputs' %in% partners) {
    groupcol <- if(isFALSE(group)) "pre_key" else group
    iam <- coconat::partner_summary2adjacency_matrix(
      x[['inputs']],
      inputcol = groupcol, outputcol = 'post_key', outputids = ids)
    cm[['cin']] = coconat::cosine_sim(iam, transpose = F)
    cm[['win']]=sum(x[['inputs']]$weight)
  }
  cm <- coconat::prepare_cosine_matrix(cm, partners = partners, action=nas)
  cm
}


#' Multi dataset cosine clustering
#'
#' @details \code{group=FALSE} only makes sense for single dataset clustering -
#'   type labels are essential for linking connectivity across datasets. However
#'   \code{group=FALSE} can be useful e.g. for co-clustering columnar elements
#'   in the visual system that have closely related partners usually because
#'   they are in neighbouring columns. At the time of writing, there is no
#'   metadata support in FANC so \code{group=FALSE} is the only option there.
#'
#'   \code{group} can be set to other metadata columns such as \code{class} or
#'   \code{hemilineage}, \code{serial} (serially homologous cell group) if
#'   available. This can reveal other interesting features of organisation.
#'
#'   The \code{labRow} argument is most conveniently specified as a length 1
#'   string to be interpolated by \code{\link{glue}}; this will happen in the
#'   context of a data frame generated by \code{\link{cf_meta}}. One reason why
#'   this is convenient is that you do not have to think about matching up the
#'   labels to the order of neurons in the dendrogram
#'
#'   However, if you need to use additional information for your labels not
#'   present in the \code{\link{cf_meta}} data then you will need to generate
#'   your own \code{labRow} vector. The recommended way to do this is to use
#'   \code{\link{cf_meta}} to fetch the metadata for your neurons and then to
#'   construct an additional column with your preferred label. This ensures that
#'   each entry in the \code{labRow} argument can be matched to a specific
#'   neuron (defined by the \code{key} column of the metadata data frame).
#'
#'   Note that if you try to pass a user defined \code{labRow} character vector
#'   without supplying an explicitly ordered set of neurons to the \code{ids}
#'   argument then you will get an error. This is because \code{cf_cosine_plot}
#'   has no way of knowing which label corresponds to which neuron, almost
#'   certainly resulting in incorrect row labels on your dendrogram.
#'
#' @param ids A set of across dataset \code{\link{keys}} \emph{or} neuron ids
#'   wrapped by \code{\link{cf_ids}} \emph{or} a dataframe compatible with the
#'   \code{\link{keys}} function.
#' @param group The name or the grouping column for partner connectivity
#'   (defaults to \code{"type"}) or a logical where \code{group=FALSE} means no
#'   grouping (see details).
#' @param labRow Optionally, either string that can be interpolated by
#'   \code{\link{glue}} \emph{or} a character vector matching the number of
#'   neurons specified by \code{ids}. See \bold{details} for an important
#'   limitation in the second case.
#' @param matrix Whether to return the raw cosine matrix (rather than a
#'   heatmap/dendrogram)
#' @param drop_dataset_prefix Whether to remove dataset prefix such as
#'   \code{hb:} or \code{fw:} from dendrograms. This is useful when reviewing
#'   neurons in interactive mode.
#' @param keep.all.meta Whether to keep all meta data information for the query
#'   neurons to allow for more flexible labelling of the dendrogram (default
#'   \code{TRUE} for convenience, so not really clear why you would want to set
#'   to \code{FALSE}). See the \code{keep.all} argument of \code{\link{cf_meta}}
#'   for details.
#' @inheritParams cf_partners
#' @inheritParams neuprintr::neuprint_cosine_plot
#'
#' @return The result of \code{\link{heatmap}} invisibly including the row and
#'   column dendrograms \emph{or} when \code{heatmap=FALSE}, an
#'   \code{\link{hclust}} dendrogram \emph{or} when \code{maxtrix=TRUE} a cosine
#'   matrix.
#' @export
#'
#' @examples
#' \donttest{
#' # basic cosine clustering, in this case for one dataset
#' cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"))
#'
#' # same but dropping the dataset prefix in the column labels
#' cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"),
#'   drop_dataset_prefix = TRUE)
#'
#' # only cluster by inputs
#' cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), partners='in')
#'
#' # or outputs
#' cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), partners='in')
#'
#' # the same but without grouping partner connectivity by type
#' # only makes sense for single dataset plots
#' cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), group = FALSE)
#'
#' ## Using user supplied row labels
#' # e.g. because you have some labels of your own that you want to add
#' library(dplyr)
#' library(glue)
#' lalmeta=cf_meta(cf_ids(hemibrain="/type:LAL00.+"))
#' # NB left_join requires the id columns to have the same character data type
#' mytypes=data.frame(
#'   id=as.character(c(5813047453, 1011611587)),
#'   mytype=c("alice", 'bob'))
#' # NB glue::glue functions makes the label using column names
#' lalmeta2=left_join(lalmeta, mytypes, by='id') %>%
#'   mutate(label=glue('{type}_{side} :: {mytype}'))
#' head(lalmeta2)
#'
#' # now use that in the plot
#' # NB with function allows cf_cosine_plot to use dataframe columns directly
#' lalmeta2 %>%
#'  with(cf_cosine_plot(key, labRow=label))
#'
#' # bigger clustering
#' lalhc=cf_cosine_plot(cf_ids(hemibrain="/type:LAL.+"), heatmap=FALSE)
#' lalmeta=cf_meta(lalhc)
#' lalmeta=coconat::add_cluster_info(lalmeta, lalhc, h=0.75, idcol='key')
#'
#' }
#' \dontrun{
#' ## The previous examples are for single datasets to avoid authentication issues
#' ## on the build server, but similar queries could be run for multiple datasets
#' cf_cosine_plot(cf_ids(flywire="/type:LAL.+", malecns="/type:LAL.+"))
#'
#' # we can use a range of dataset-specific columns to decorate labels
#' cf_cosine_plot(cf_ids(flywire="/type:LAL0.+", hemibrain="/type:LAL0.+"),
#'   labRow = "{top_nt}")
#'
#' cf_cosine_plot(cf_ids("/type:LAL.+", datasets='brain'))
#' # same as since the default is brain
#' cf_cosine_plot(cf_ids("/type:LAL.+"))
#'
#' # just make the hclust dendrogram
#' lalhc=cf_cosine_plot(cf_ids("/type:LAL.+"), heatmap=FALSE)
#' lalmeta=cf_meta(lalhc)
#' lalmeta=coconat::add_cluster_info(lalmeta, lalhc, h=0.75)
#'
#' # plot results in a big dendrogram
#' pdf("lalhc.pdf", width = 150,height = 20, family = 'Courier')
#' plot(lalhc, labels=glue::glue_data("{type}_{abbreviate_datasets(dataset)}{side}",
#'  .x=lalmeta), hang = -.01, cex=.7)
#' dev.off()
#'
#' # look at the results interactively
#' cf_cosine_plot(cf_ids("/type:LAL.+"), interactive=TRUE)
#' }
#'
#' \donttest{
#' # Showcase examples using multi_connection_table to allow
#' # only a subset of partners to be used for typing
#' mct=multi_connection_table(cf_ids(hemibrain="/lLN2.+"), partners='in')
#' cf_cosine_plot(mct)
#' library(dplyr)
#' mct2=mct %>% filter(!grepl("PN",type))
#' cf_cosine_plot(mct2)
#'
#' mct3=cf_ids("/type:lLN2.+", datasets=c("hemibrain", "flywire")) %>%
#'   multi_connection_table(., partners='in') %>%
#'   mutate(class=case_when(
#'    grepl("LN", type) ~ "LN",
#'    grepl("RN", type) ~ "RN",
#'    grepl("^M.*PN", type) ~ 'mPN',
#'    grepl("PN", type) ~ 'uPN',
#'    TRUE ~ 'other'
#'   )) %>%
#'   # try merging connectivity for partners that don't have much specificity
#'   mutate(type=case_when(
#'   class=="RN" ~ sub("_.+", "", type),
#'   class=="uPN" ~ 'uPN',
#'   TRUE ~ type
#'   ))
#' \dontrun{
#' mct3%>%
#'   # remove RN/uPN connectivity could also use the merged connectivity
#'   filter(!class %in% c("RN", "uPN")) %>%
#'   cf_cosine_plot(interactive=TRUE)
#' }
#'
#' # This time focus in on a small number of query neurons
#' mct3 %>%
#'   mutate(query_key=ifelse(partners=='outputs', pre_key, post_key)) %>%
#'   filter(query_key %in% cf_ids('/type:lLN2(T_[bde]|X08)',
#'     datasets = c("hemibrain", "flywire"), keys = TRUE)) %>%
#'   cf_cosine_plot()
#' }
#'
#' # another worked example lLN1 neurons
#' \donttest{
#' lLN1=cf_ids("/type:lLN1_.+", datasets=c("hemibrain", "flywire")) %>%
#'   multi_connection_table(., partners='in') %>%
#'   mutate(class=case_when(
#'    grepl("LN", type) ~ "LN",
#'    grepl("RN", type) ~ "RN",
#'    grepl("^M.*PN", type) ~ 'mPN',
#'    grepl("PN", type) ~ 'uPN',
#'    TRUE ~ 'other'
#'   )) %>%
#'   mutate(type=case_when(
#'   class=="RN" ~ sub("_.+", "", type),
#'   class=="uPN" ~ 'uPN',
#'   TRUE ~ type
#'   ))
#'
#' lLN1 %>%
#'   filter(!class %in% c("RN", "uPN")) %>%
#'   cf_cosine_plot()
#' }
cf_cosine_plot <- function(ids=NULL,
                           ...,
                           threshold=5,
                           partners = c("outputs", "inputs"),
                           labRow='{type}_{coconatfly::abbreviate_datasets(dataset)}{side}',
                           group='type',
                           heatmap=TRUE,
                           matrix=FALSE,
                           interactive=FALSE,
                           drop_dataset_prefix=FALSE,
                           keep.all.meta=TRUE,
                           min_datasets=Inf,
                           nas=c('zero','drop'),
                           method=c("ward.D", "single", "complete", "average",
                                    "mcquitty", "median", "centroid", "ward.D2")) {
  method=match.arg(method)
  partners=match.arg(partners, several.ok = T)
  if(is.mct(ids)) {
    x=ids
    partners=unique(x$partners)
  } else
    x=multi_connection_table(ids, partners = partners, threshold = threshold, group=group, min_datasets = min_datasets, ...)

  cm <- multi_cosine_matrix(x, partners = partners, group=group, nas=nas)

  if(is.character(labRow) && length(labRow)==1 && any(grepl("\\{", labRow))) {
    tm=cf_meta(colnames(cm), keep.all = keep.all.meta, ...)
    labRow <- glue::glue_data(labRow, .x = tm)
  } else if(is.character(labRow)) {
    # user has supplied labels but they are unlikely to be in the correct order
    # see if there is an implicit order defined by ids argument
    if(is.data.frame(ids)) {
      if('key' %in% colnames(ids))
        ids=ids$key
      else {
        ids=try(keys(ids), silent = T)
        if(inherits(ids, "try-error"))
          stop("You have supplied `labRow` as vector of labels but I cannot match each label to a specific neuron.\n",
               "In future please pass keys or a dataframe to the `ids` argument.\n",
               "This defines a precise order of neurons that I can match your labRow argument.\n",
               "See details section and examples for more information.")
      }
    }

    if(all(is_key(ids))) {
      # we were given keys so we can expect that labRow is in the same order
      labRow=labRow[match(colnames(cm), ids)]
    }
  }
  if(interactive) {
    try(cv <- requireNamespace('coconat', versionCheck=list(op='>', version='0.1.0')))
    if(inherits(cv, 'try-error'))
      stop("Please install/update suggested package coconat.\n",
           "natmanager::install(pkgs = 'coconat')\n","is a good way to do this")
  }
  if(drop_dataset_prefix)
    colnames(cm)=sub("^[a-z]+:","", colnames(cm))
  if(isTRUE(matrix))
    return(cm)
  coconat:::cosine_heatmap(cm, interactive = interactive, labRow = labRow,
                           method = method, heatmap=heatmap, ...)
}


#' @importFrom dplyr distinct all_of
#' @param check_missing Whether to report if any query neurons are dropped (due
#'   to insufficient partner neurons) (default:\code{TRUE}).
#' @param min_datasets How many datasets a type must be in to be included in the
#'   output. The default of \code{Inf} => all datasets must contain the cell
#'   type. A negative number defines the number of datasets from which a type
#'   can be missing. For example \code{-1} would mean that types would still be
#'   included even if they are missing from one dataset.
#'
#' @rdname cf_cosine_plot
#' @export
#' @return \code{multi_connection_table} returns a connectivity dataframe as
#'   returned by \code{cf_partners} but with an additional column
#'   \code{partners} which indicates (for each row) whether the partner neurons
#'   are the input or output neurons.
multi_connection_table <- function(ids, partners=c("inputs", "outputs"),
                                   threshold=1L, group='type',
                                   check_missing=TRUE,
                                   min_datasets=Inf,
                                   ...
                                   ) {
  if(isTRUE(group))
    group='type'
  partners=match.arg(partners, several.ok = T)
  kk=keys(ids)
  if(length(partners)>1) {
    l=sapply(partners, simplify = F, function(p)
      multi_connection_table(kk, partners=p, threshold = threshold, group=group,
                             check_missing=F, min_datasets = min_datasets, ...))
    l=dplyr::bind_rows(l)
    if(check_missing) {
      query_keys <- l %>% group_by(partners) %>%
        mutate(query=case_when(
          partners=='inputs' ~ post_key,
          partners=='outputs' ~ pre_key,
        )) %>%
        pull(query)
      missing_keys=setdiff(unique(kk), query_keys)
      nmissing=length(missing_keys)
      if(nmissing>0)
        warning("Dropping ", nmissing, " keys. Try decreasing threshold!")
    }

    return(l)
  }
  kdf=keys2df(kk)
  datasets=unique(kdf$dataset)
  MoreArgs=list()
  if(length(datasets)>1 && "malecns" %in% datasets)
    MoreArgs=list(malecns=list(prefer.foreign=TRUE))
  x <- cf_partners(kk, threshold = threshold, partners = partners, MoreArgs = MoreArgs)
  if(is.character(group))
    x <- match_types(x, group, partners=partners, min_datasets = min_datasets)
  # mark which column was used for the query
  x$partners=partners
  # check if some incoming ids were dropped
  if(check_missing) {
    missing_keys <- if(partners=='inputs') {
      setdiff(unique(kk), x$post_key)
    } else {
      setdiff(unique(kk), x$pre_key)
    }
    nmissing=length(missing_keys)
    if(nmissing>0)
      warning("Dropping ",nmissing, " keys. Try decreasing threshold!")
  }
  x
}

is.mct <- function(x) {
  is.data.frame(x) && all(c("pre_id", "post_id", "dataset", "partners") %in% colnames(x))
}

