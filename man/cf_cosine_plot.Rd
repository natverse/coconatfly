% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cosine.R
\name{cf_cosine_plot}
\alias{cf_cosine_plot}
\alias{multi_connection_table}
\title{Multi dataset cosine clustering}
\usage{
cf_cosine_plot(
  ids = NULL,
  ...,
  threshold = 5,
  partners = c("outputs", "inputs"),
  labRow = "{type}_{coconatfly::abbreviate_datasets(dataset)}{side}",
  group = "type",
  heatmap = TRUE,
  matrix = FALSE,
  interactive = FALSE,
  drop_dataset_prefix = FALSE,
  nas = c("zero", "drop"),
  method = c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid",
    "ward.D2")
)

multi_connection_table(
  ids,
  partners = c("inputs", "outputs"),
  threshold = 1L,
  group = "type",
  check_missing = TRUE
)
}
\arguments{
\item{ids}{A set of across dataset \code{\link{keys}} \emph{or} neuron ids
wrapped by \code{\link{cf_ids}} \emph{or} a dataframe compatible with the
\code{\link{keys}} function.}

\item{...}{Additional arguments passed to \code{\link{heatmap}}}

\item{threshold}{return only edges with at least this many matches. 0 is an
option since neuprint sometimes returns 0 weight edges.}

\item{partners}{Whether to return inputs or outputs}

\item{labRow}{Optionally, either string that can be interpolated by
\code{\link{glue}} \emph{or} a character vector matching the number of
neurons specified by \code{ids}. See \bold{details} for an important
limitation in the second case.}

\item{group}{The name or the grouping column for partner connectivity
(defaults to \code{"type"}) or a logical where \code{group=FALSE} means no
grouping (see details).}

\item{heatmap}{A logical indicating whether or not to plot the heatmap
\emph{OR} a function to plot the heatmap whose argument names are
compatible with \code{stats::\link{heatmap}}. \code{gplots::heatmap.2} is a
good example. Defaults to \code{TRUE} therefore plotting the full heatmap
with \code{stats::\link{heatmap}}.}

\item{matrix}{Whether to return the raw cosine matrix (rather than a
heatmap/dendrogram)}

\item{interactive}{Whether to plot an interactive heatmap (allowing zooming
and id selection). See details.}

\item{drop_dataset_prefix}{Whether to remove dataset prefix such as
\code{hb:} or \code{fw:} from dendrograms. This is useful when reviewing
neurons in interactive mode.}

\item{nas}{What to do with entries that have NAs. Default is to set them to 0
similarity.}

\item{method}{The cluster method to use (see \code{\link{hclust}})}

\item{check_missing}{Whether to report if any query neurons are dropped (due
to insufficient partner neurons) (default:\code{TRUE}).}
}
\value{
The result of \code{\link{heatmap}} invisibly including the row and
  column dendrograms \emph{or} when \code{heatmap=FALSE}, an
  \code{\link{hclust}} dendrogram \emph{or} when \code{maxtrix=TRUE} a cosine
  matrix.

\code{multi_connection_table} returns a connectivity dataframe as
  returned by \code{cf_partners} but with an additional column
  \code{partners} which indicates (for each row) whether the partner neurons
  are the input or output neurons.
}
\description{
Multi dataset cosine clustering
}
\details{
\code{group=FALSE} only makes sense for single dataset clustering -
  type labels are essential for linking connectivity across datasets. However
  \code{group=FALSE} can be useful e.g. for co-clustering columnar elements
  in the visual system that have closely related partners usually because
  they are in neighbouring columns. At the time of writing, there is no
  metadata support in FANC so \code{group=FALSE} is the only option there.

  \code{group} can be set to other metadata columns such as \code{class} or
  \code{hemilineage}, \code{serial} (serially homologous cell group) if
  available. This can reveal other interesting features of organisation.

  The \code{labRow} argument is most conveniently specified as a length 1
  string to be interpolated by \code{\link{glue}}; this will happen in the
  context of a data frame generated by \code{\link{cf_meta}}. One reason why
  this is convenient is that you do not have to think about matching up the
  labels to the order of neurons in the dendrogram

  However, if you need to use additional information for your labels not
  present in the \code{\link{cf_meta}} data then you will need to generate
  your own \code{labRow} vector. The recommended way to do this is to use
  \code{\link{cf_meta}} to fetch the metadata for your neurons and then to
  construct an additional column with your preferred label. This ensures that
  each entry in the \code{labRow} argument can be matched to a specific
  neuron (defined by the \code{key} column of the metadata data frame).

  Note that if you try to pass a user defined \code{labRow} character vector
  without supplying an explicitly ordered set of neurons to the \code{ids}
  argument then you will get an error. This is because \code{cf_cosine_plot}
  has no way of knowing which label corresponds to which neuron, almost
  certainly resulting in incorrect row labels on your dendrogram.
}
\examples{
\donttest{
# basic cosine clustering, in this case for one dataset
cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"))

# same but dropping the dataset prefix in the column labels
cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"),
  drop_dataset_prefix = TRUE)

# only cluster by inputs
cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), partners='in')

# or outputs
cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), partners='in')

# the same but without grouping partner connectivity by type
# only makes sense for single dataset plots
cf_cosine_plot(cf_ids(hemibrain="/type:LAL00.+"), group = FALSE)

## Using user supplied row labels
# e.g. because you have some labels of your own that you want to add
library(dplyr)
library(glue)
lalmeta=cf_meta(cf_ids(hemibrain="/type:LAL00.+"))
# NB left_join requires the id columns to have the same character data type
mytypes=data.frame(
  id=as.character(c(5813047453, 1011611587)),
  mytype=c("alice", 'bob'))
# NB glue::glue functions makes the label using column names
lalmeta2=left_join(lalmeta, mytypes, by='id') \%>\%
  mutate(label=glue('{type}_{side} :: {mytype}'))
head(lalmeta2)

# now use that in the plot
# NB with function allows cf_cosine_plot to use dataframe columns directly
lalmeta2 \%>\%
 with(cf_cosine_plot(key, labRow=label))

# bigger clustering
lalhc=cf_cosine_plot(cf_ids(hemibrain="/type:LAL.+"), heatmap=FALSE)
lalmeta=cf_meta(lalhc)
lalmeta=coconat::add_cluster_info(lalmeta, lalhc, h=0.75, idcol='key')

}
\dontrun{
## The previous examples are for single datasets to avoid authentication issues
## on the build server, but similar queries could be run for multiple datasets
cf_cosine_plot(cf_ids(flywire="/type:LAL.+", malecns="/type:LAL.+"))

cf_cosine_plot(cf_ids("/type:LAL.+", datasets='brain'))
# same as since the default is brain
cf_cosine_plot(cf_ids("/type:LAL.+"))

# just make the hclust dendrogram
lalhc=cf_cosine_plot(cf_ids("/type:LAL.+"), heatmap=FALSE)
lalmeta=cf_meta(lalhc)
lalmeta=coconat::add_cluster_info(lalmeta, lalhc, h=0.75)

# plot results in a big dendrogram
pdf("lalhc.pdf", width = 150,height = 20, family = 'Courier')
plot(lalhc, labels=glue::glue("{type}_{abbreviate_datasets(dataset)}{side}",
 .envir =lalmeta), hang = -.01, cex=.7)
dev.off()

# look at the results interactively
cf_cosine_plot(cf_ids("/type:LAL.+"), interactive=TRUE)
}

\donttest{
# Showcase examples using multi_connection_table to allow
# only a subset of partners to be used for typing
mct=multi_connection_table(cf_ids(hemibrain="/lLN2.+"), partners='in')
cf_cosine_plot(mct)
library(dplyr)
mct2=mct \%>\% filter(!grepl("PN",type))
cf_cosine_plot(mct2)

mct3=cf_ids("/type:lLN2.+", datasets=c("hemibrain", "flywire")) \%>\%
  multi_connection_table(., partners='in') \%>\%
  mutate(class=case_when(
   grepl("LN", type) ~ "LN",
   grepl("RN", type) ~ "RN",
   grepl("^M.*PN", type) ~ 'mPN',
   grepl("PN", type) ~ 'uPN',
   TRUE ~ 'other'
  )) \%>\%
  # try merging connectivity for partners that don't have much specificity
  mutate(type=case_when(
  class=="RN" ~ sub("_.+", "", type),
  class=="uPN" ~ 'uPN',
  TRUE ~ type
  ))
\dontrun{
mct3\%>\%
  # remove RN/uPN connectivity could also use the merged connectivity
  filter(!class \%in\% c("RN", "uPN")) \%>\%
  cf_cosine_plot(interactive=TRUE)
}

# This time focus in on a small number of query neurons
mct3 \%>\%
  mutate(query_key=ifelse(partners=='outputs', pre_key, post_key)) \%>\%
  filter(query_key \%in\% cf_ids('/type:lLN2(T_[bde]|X08)',
    datasets = c("hemibrain", "flywire"), keys = TRUE)) \%>\%
  cf_cosine_plot()
}

# another worked example lLN1 neurons
\donttest{
lLN1=cf_ids("/type:lLN1_.+", datasets=c("hemibrain", "flywire")) \%>\%
  multi_connection_table(., partners='in') \%>\%
  mutate(class=case_when(
   grepl("LN", type) ~ "LN",
   grepl("RN", type) ~ "RN",
   grepl("^M.*PN", type) ~ 'mPN',
   grepl("PN", type) ~ 'uPN',
   TRUE ~ 'other'
  )) \%>\%
  mutate(type=case_when(
  class=="RN" ~ sub("_.+", "", type),
  class=="uPN" ~ 'uPN',
  TRUE ~ type
  ))

lLN1 \%>\%
  filter(!class \%in\% c("RN", "uPN")) \%>\%
  cf_cosine_plot()
}
}
